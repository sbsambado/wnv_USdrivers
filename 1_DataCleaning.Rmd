---
title: "1_DataExtraction"
output: html_document
date: "2025-08-07"
---

#

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

## upload necessary packages
library(tigris)
library(tidyverse)
library(janitor)
library(tidycensus)
library(raster)
library(exactextractr)
library(sf)
library(terra)
library(stringr)

```

Spatial boundaries
```{r}
## US county boundaries
counties_sf <- tigris::counties(year = 2020, cb = TRUE, class = "sf")


## US state boundaries
all_states_sf <- tigris::states(year = 2020, cb = TRUE, class = "sf") # for figures
states_sf <- all_states_sf[!all_states_sf$STUSPS %in% c("PR", "VI", "GU", "MP", "AS", "AK" ,"HI"), ] # omit territories

## US county centroid lat, lon
county_centroids <- st_centroid(counties_sf)
county_centroids$lon  <- st_coordinates(county_centroids)[,1]
county_centroids$lat  <- st_coordinates(county_centroids)[,2]
```



##Human WNV incidence

###WNV incidence
```{r}
## CDC ArboNET 
## A. upload data
arbonet_raw <- read.csv("data/raw/arbonet_wnv/wnvnd_avgannualincidence_county_19992023.csv")


## B. wrangle data
arbonet_clean <- arbonet_raw %>% 
  clean_names() %>% 
  rename(GEOID = county) %>% 
  mutate(GEOID = str_pad(GEOID, width = 5, pad = 0), # make sure FIPS are 5 characters
         GEOID = as.character(GEOID)) %>% 
  right_join(counties_sf %>% 
               dplyr::select(GEOID, geometry), by = "GEOID") %>% 
  dplyr::select(GEOID, incidence) # could keep population 

## C. make data spatial
arbonet_spatial <- counties_sf %>% 
  left_join(arbonet_clean, by = "GEOID")
  
## D. check 
ggplot(arbonet_spatial) +
  geom_sf(aes(fill = incidence), color = NA, size = 0.05, show.legend = TRUE) +
  geom_sf(data = states_sf, fill = NA, color = "black", size = 0.2) +
  coord_sf(xlim = c(-125, -66.5), ylim = c(24, 50), expand = FALSE) 

# write csv
arbonet_spatial %>% st_drop_geometry() %>% dplyr::select(-c(STATEFP:AFFGEOID,NAME:AWATER)) %>% 
  write.csv("data/processed/arbonet_wnvnd.csv")
```

###Demographic structure of 65+
```{r}
# CT codes https://www.bls.gov/cew/classifications/areas/new-2024-connecticut-counties.htm
## need to use counties_sf for 2024 to merge CT
counties_sf_2024 <- tigris::counties(year = 2024, cb = TRUE, class = "sf")

## American Community Survey (ACS)
## A. upload data
acs_percover65 <- get_acs(geography = "county",
        variables = c(over65 = "S0101_C02_030E",
                      year = 2020,
                      survey = "acs5"))

## B. wrangle data
acs_percover65_clean <- acs_percover65 %>% 
  mutate(GEOID = str_pad(GEOID, width = 5, pad = 0),
         GEOID = as.character(GEOID)) %>% 
  rename(perc_over65 = estimate,
         error = moe) 

## C. make data spatial
acs_percover65_spatial <- counties_sf_2024 %>% 
  left_join(acs_percover65_clean %>% dplyr::select(GEOID, perc_over65), by = "GEOID")

## CT is weird need to convert new GEOID to old GEOID so it merges with all the other data 
# (CT went from 8 to 9 "planning regions")
acs_percover65_spatial %>% filter(STATEFP == "09")

acs_percover65_spatial_CTcorrected <- acs_percover65_spatial %>%
  mutate(GEOID = case_when(
    GEOID == "09110" ~ "09013",  # Capitol to Tolland
    GEOID == "09120" ~ "09001",  #Greater Bridgeport to Fairfield
    GEOID == "09130" ~ "09007",  # Lower CT River Valley to Middlesex
    GEOID == "09140" ~ "09009",  # Naugatuck Valley to New Haven
    GEOID == "09150" ~ "09015",  # Northeastern CT t- Windham
    GEOID == "09160" ~ "09005",  # Northwest Hills to Litchfield
    GEOID == "09170" ~ "09009",  # South Central CT to New Haven
    GEOID == "09180" ~ "09011",  # Southeastern CT to New London
    GEOID == "09190" ~ "09003",  # Western CT to Hartford
    TRUE ~ GEOID)) 
    

# 09190 
## D. check 
ggplot(acs_percover65_spatial_CTcorrected) +
  geom_sf(aes(fill = perc_over65), color = NA, size = 0.05, show.legend = TRUE) +
  geom_sf(data = states_sf, fill = NA, color = "black", size = 0.2) +
  coord_sf(xlim = c(-125, -66.5), ylim = c(24, 50), expand = FALSE) 

# write csv
acs_percover65_spatial_CTcorrected %>% st_drop_geometry() %>% dplyr::select(c(GEOID, perc_over65)) %>% 
  write.csv("data/processed/acs_over65.csv")
```


##Landscape metrics

Figure 1a
```{r}
## A. upload data
nlcd <- raster::raster("data/raw/nlcd/nlcd_annuallndcv_2020_cu_c1v0.tif")

# NLCD codes
# 0:Unclassified
# 11:Open Water
# 12:Perennial Snow/Ice
# 21:Developed, Open Space
# 22:Developed, Low Intensity
# 23:Developed, Medium Intensity
# 24:Developed, High Intensity
# 31:Barren Land
# 41:Deciduous Forest
# 42:Evergreen Forest
# 43:Mixed Forest
# 52:Shrub/Scrub
# 71:Herbaceous
# 81:Hay/Pasture
# 82:Cultivated Crops
# 90:Woody Wetlands
# 95:Emergent Herbaceous Wetlands

## B. state codes for study
urban_codes <- c(21, 22, 23, 24)
ag_codes <- c(81, 82)


## C. extract raster for each county
# what % of county is urban land cover?
urban_pct <- exactextractr::exact_extract(nlcd,
                                          counties_sf,
                                          function(values, coverage_fractions) {
                                            # calc total pixels that are urban codes & divide by
                                            sum(coverage_fractions[values %in% c(21, 22, 23, 24)], na.rm = TRUE)/
                                              
                                            # total pixels per county
                                              sum(coverage_fractions,  na.rm = TRUE)
                                          })


# what % of county is ag land cover?
ag_pct <- exactextractr::exact_extract(nlcd,
                                          counties_sf,
                                          function(values, coverage_fractions) {
                                            # calc total pixels that are urban codes & divide by
                                            sum(coverage_fractions[values %in% c(81, 82)], na.rm = TRUE)/
                                              
                                            # total pixels per county
                                              sum(coverage_fractions,  na.rm = TRUE)
                                          })

## D. Add metadata
# urban
urban_pct_results <- counties_sf %>% # shapefile
  mutate(urban_pct = urban_pct) %>% # make new column
  st_drop_geometry() %>% # drop geometry info
  dplyr::select(GEOID, urban_pct) %>% # select main columns
  mutate(GEOID = str_pad(GEOID, width = 5, pad = 0), # make sure GEOID has 5 numbers or wont merge
         GEOID = as.character(GEOID)) # make character to merge across dfs

# ag
ag_pct_results <- counties_sf %>% # shapefile
  mutate(ag_pct = ag_pct) %>% # make new column
  st_drop_geometry() %>% # drop geometry info
  dplyr::select(GEOID, ag_pct) %>% # select main columns
  mutate(GEOID = str_pad(GEOID, width = 5, pad = 0), # make sure GEOID has 5 numbers or wont merge
         GEOID = as.character(GEOID)) # make character to merge across dfs

## E. Save NLCD processed data
nlcd_urbanag <- urban_pct_results %>% 
  left_join(ag_pct_results, by = "GEOID") #%>% write.csv("data/processed/nlcd_urbanag_pct.csv")

## F. merge urban & ag together
nlcd_perc_spatial <- counties_sf %>% 
  left_join(nlcd_urbanag, by = "GEOID") %>% 
  # make new column for 3x3 binning category for figure
  mutate(urban_category = ntile(urban_pct, 3),
         ag_category = ntile(ag_pct, 3),
         bivariate_class = paste0(ag_category, "-", urban_category))

## G. make color palette
bivariate_pal <- c("1-1" = "#e8e8e8", "1-2" = "#ace4e4", "1-3" = "#5ac8c8",
                   "2-1" = "#dfb0d6", "2-2" = "#a5add3", "2-3" = "#5698b9",
                   "3-1" = "#be64ac", "3-2" = "#8c62aa", "3-3" = "#3b4994")


## H. plot it!
ggplot(nlcd_perc_spatial) +
  geom_sf(aes(fill = bivariate_class), color = NA, size = 0.05, show.legend = TRUE) +
  scale_fill_manual(values = bivariate_pal) +
  geom_sf(data = states_sf, fill = NA, color = "black", size = 0.2) +
  coord_sf(xlim = c(-125, -66.5), ylim = c(24, 50), expand = FALSE)
```

Edge density metric
```{r}
## Optional: help speed up things on my computer
# Set terra options globally (optional but helpful)
terraOptions(memfrac = 0.9, gdal = c("COMPRESS=DEFLATE", "PREDICTOR=2"))


# landscape metrics https://r-spatialecology.github.io/landscapemetrics/
## A. upload data
nlcd <- terra::rast("data/raw/nlcd/nlcd_annuallndcv_2020_cu_c1v0.tif")

## B. state codes for study
urban_codes <- c(21, 22, 23, 24)
ag_codes <- c(81, 82)

## C. Create binary rasters
urban_mask <- nlcd %in% urban_codes # if pixel is urban = 1, else NA
ag_mask <- nlcd %in% ag_codes # if pixel is ag = 1, else NA
# check
plot(ag_mask)

# save these binary files incase I want to do something different than edge density
writeRaster(urban_mask, "data/processed/nlcd_urbanmask.tif", overwrite = TRUE)
writeRaster(ag_mask, "data/processed/nlcd_agmask.tif", overwrite = TRUE)



## D. identify urban pixels adjacet to Ag (using 3x3 window)
# make 8 neighbor window
window <- matrix(1,3,3) 
# make ag neighbor patches 
ag_neighbors <- focal(ag_mask, w = window, fun = sum, na.policy = "omit",
                      # help with memory issues
                      filename = "data/processed/nlcd_agneighbors.tif",
                      overwrite = TRUE,
                      wopt = list(gdal = c("COMPRESS=DEFLATE", "PREDICTOR=2", "ZLEVEL=1"))) 

# now see if urban pixel has at least 1 ag neighbor, which would make it an edge
writeRaster((urban_mask == 1) & (ag_neighbors > 0),
            # help with memory issues
                      filename = "data/processed/nlcd_urbanagedge.tif",
                      overwrite = TRUE,
                      wopt = list(gdal = c("COMPRESS=DEFLATE", "PREDICTOR=2", "ZLEVEL=1")))

urban_ag_edge <- rast("data/processed/nlcd_urbanagedge.tif")
# urban pixel w/ 1 ag adjacent pixel = TRUE
# urban pixel w/ no ag adjacent pixel = FALSE
# non-urban pixels = FALSE

#plot(urban_ag_edge)



## E. Define county boundaries 
# slighltly different for other ones bc i want to minimize resolution to speed up processing
counties_5m <- counties(cb = TRUE, resolution = "5m", year = 2020)
counties_5m_sf <- st_as_sf(counties_5m) %>% 
  filter(!STATEFP %in% c("02", "15", "72")) #non CONUS states

## F. Align CRSs
counties_5m_vect <- vect(counties_5m_sf)
if(!identical(crs(counties_5m_vect), crs(urban_ag_edge))) {
  counties_5m_vect <- project(counties_5m_vect, crs(urban_ag_edge))
}

## G. Rasterize counties
# simplify geometry - helps speed things up a bit
counties_5m_simple <- simplifyGeom(counties_5m_vect, tolerance = 100)
counties_5m_raster <- rasterize(counties_5m_simple, 
                                urban_ag_edge, 
                                field = "GEOID",
                                touches = FALSE,# only if cell center falls within county polygon
                                background = NA)



## H. Count urban-ag edge pixels per county
edge_counts <- zonal(urban_ag_edge, counties_5m_raster, fun = "sum", na.rm = TRUE)

# format GEOID column
edge_counts_clean <- edge_counts %>% 
  mutate(GEOID = str_pad(as.character(GEOID), width = 5, pad = "0"),
         edge_pixel_count = get(names(edge_counts)[2])) %>% 
  dplyr::select(GEOID, edge_pixel_count)


## I. Calculation edge length and density
# NLCD pixel sizes are 30 m 
pixel_size <- res(urban_ag_edge)[1]

edge_summary <- counties_5m_sf %>% 
  left_join(edge_counts_clean, by = "GEOID") %>% 
  mutate(edge_pixel_count = replace_na(edge_pixel_count, 0),
         edge_length_m = edge_pixel_count * pixel_size,
         area_km2 = as.numeric(st_area(geometry))/ 1e6,
         edge_density_mk2 = edge_length_m/area_km2,
         log_edge_density_mk2 = log(edge_length_m/area_km2+1))

## save output
st_write(edge_summary, "data/processed/nlcd_edgedensity.gpkg", delete_layer = TRUE)
edge_summary %>% st_drop_geometry() %>% dplyr::select(-c(STATEFP:AFFGEOID,NAME:AWATER)) %>% 
  write.csv("data/processed/nlcd_urbanag_edgesummary.csv")
# high value = More fragmented or interspersed land use â€” urban and agricultural areas are closely mixed.
# low value = Land is more homogeneously urban or agricultural

## J. plot it!
ggplot(edge_summary) +
  geom_sf(aes(fill = edge_density_mk2), color = NA, size = 0.05, show.legend = TRUE) +
  geom_sf(data = states_sf, fill = NA, color = "black", size = 0.2) +
  coord_sf(xlim = c(-125, -66.5), ylim = c(24, 50), expand = FALSE)

```

##Human exposure metrics

Occupational exposure
```{r}
## A. make function to pull in various ag.csv and wrangle the data
agemployment_function <- function(year) {
  # set file paths
  path_111 <- glue::glue("data/raw/bls_qcew/{year}_111.csv")
  path_1151 <- glue::glue("data/raw/bls_qcew/{year}_1151.csv")
  path_10 <- glue::glue("data/raw/bls_qcew/{year}_10.csv")
  
  # load data
  naics_111 <- read_csv(path_111, show_col_types = FALSE)
  naics_1151 <- read_csv(path_1151, show_col_types = FALSE)
  naics_10 <- read_csv(path_10, show_col_types = FALSE) %>% filter(own_code == 5) # only private sector
  
  # summarize by employment grouping
  ag_111 <- naics_111 %>%
    group_by(area_fips) %>%
    summarise(ag_emplvl_111 = sum(annual_avg_emplvl, na.rm = TRUE), .groups = "drop")
  
  ag_1151 <- naics_1151 %>%
    group_by(area_fips) %>%
    summarise(ag_emplvl_1151 = sum(annual_avg_emplvl, na.rm = TRUE), .groups = "drop")
  
  ag_totals <- full_join(ag_111, ag_1151, by = "area_fips") %>%
    mutate(across(starts_with("ag_emplvl"), ~ replace_na(., 0)),
           ag_total = ag_emplvl_111 + ag_emplvl_1151)
  
  # summarize total employment
  all_employment_total <- naics_10 %>%
    group_by(area_fips) %>%
    summarise(total_emplvl = sum(annual_avg_emplvl, na.rm = TRUE), .groups = "drop")
  
  # join & calculate proportion in agriculture
  all_employment <- ag_totals %>%
    left_join(all_employment_total, by = "area_fips") %>%
    mutate(ag_prop = ag_total / total_emplvl,
           ag_prop = ifelse(is.infinite(ag_prop), NA, ag_prop))
  
  #filter to true counties only (remove state rollups/aggregates)
  all_employment <- all_employment %>%
    filter(str_detect(area_fips, "^\\d{5}$"),
           !str_detect(area_fips, "000$|999$")) %>%
    mutate(GEOID = area_fips,
           year = year)

  
  return(all_employment)
  
}

# state which year's i'm looping through 
years <- 2020:2023

## B. Apply function
allemployment_calc <- map_df(years, agemployment_function)


## C. refine data
allemployment_clean <- allemployment_calc %>%
  mutate(GEOID = str_pad(GEOID, width = 5, side = "left", pad = "0")) %>% 
  group_by(GEOID) %>% 
  summarise(bls_agemploy = mean(ag_prop, na.rm = TRUE)) 

## D. make it spatial 
allemployment_spatial <- counties_sf %>% 
  left_join(allemployment_clean, by = "GEOID")  %>%
  # made the decision that counties with no reported ag meant there was no ag so assigned 0
  mutate(bls_agemploy = if_else(is.na(bls_agemploy), 0, bls_agemploy))


## E. plot it!
ggplot(allemployment_spatial) +
  geom_sf(aes(fill = bls_agemploy), color = NA, size = 0.05, show.legend = TRUE) +
  geom_sf(data = states_sf, fill = NA, color = "black", size = 0.2) +
  coord_sf(xlim = c(-125, -66.5), ylim = c(24, 50), expand = FALSE)

# write csv
allemployment_spatial %>% st_drop_geometry() %>% dplyr::select(GEOID,bls_agemploy) %>% 
  write.csv("data/processed/bls_agemployed.csv")

```

Residential exposure
```{r}
# https://svi.cdc.gov/dataDownloads/data-download.html

## A. read in data
year_svi <- c(2018, 2020, 2022)
svi_data <- map_df(year_svi, ~ {
  read_csv(glue::glue("data/raw/cdc_svi/SVI_{.x}_US_county.csv"), show_col_types = FALSE) %>% 
  mutate(year = .x)
})

## B. format data
svi_clean <- svi_data %>% 
  clean_names() %>% 
  rename("GEOID" = "fips") %>% 
  mutate(GEOID = str_pad(GEOID, width = 5, pad = 0), # make sure FIPS are 5 characters
         GEOID = as.character(GEOID)) %>% 
  dplyr::select(GEOID, year, rpl_themes) %>% 
  filter(rpl_themes > 0.0000) %>% # means there's been an error
  group_by(GEOID) %>% 
  summarise(svi_mean = mean(rpl_themes, na.rm = TRUE))


## C. make it spatial
svi_spatial <- counties_sf %>% 
  left_join(svi_clean, by = "GEOID")

## D. plot it!
ggplot(svi_spatial) +
  geom_sf(aes(fill = svi_mean), color = NA, size = 0.05, show.legend = TRUE) +
  geom_sf(data = states_sf, fill = NA, color = "black", size = 0.2) +
  coord_sf(xlim = c(-125, -66.5), ylim = c(24, 50), expand = FALSE)

# write csv
svi_spatial %>% st_drop_geometry() %>% dplyr::select(GEOID,svi_mean) %>% 
  write.csv("data/processed/cdc_svi.csv")
```

##Bird host metric
```{r}
## this code definitely can be improved upon for scalable purposes...

## A. make function to read in data quicker
usgs_filepath <- "data/raw/usgs_gap/birdspecies_range/"

read_birdrange <- function(species_folder, shapefile_name){
  shp_path <- file.path(usgs_filepath, species_folder, shapefile_name, paste0(shapefile_name, ".shp"))
  st_read(shp_path) %>% st_transform(crs = st_crs(counties_sf))
}

## B. write out species list (this is a pain and should be improved upon)
species_list <- list(
  bluejay = "bBLJAx_CONUS_Range_2001v1",
  westernscrubjay = "bWESJx_CONUS_Range_2001v1",
  americancrow = "bAMCRx_CONUS_Range_2001v1",
  commongrackle = "bCOGRx_CONUS_Range_2001v1",
  housefinch = "bHOFIx_CONUS_Range_2001v1",
  housesparrow = "bHOSPx_CONUS_Range_2001v1",
  ringbilledgull = "bRBGUx_CONUS_Range_2001v1",
  blackbilledmagpie = "bBBMAx_CONUS_Range_2001v1",
  americanrobin = "bAMROx_CONUS_Range_2001v1",
  songsparrow = "bSOSPx_CONUS_Range_2001v1",
  easternscreechowl = "bEASOx_CONUS_Range_2001v1",
  greatersagegrouse = "bGRSGx_CONUS_Range_2001v1",
  killdeer = "bKILLx_CONUS_Range_2001v1",
  americankestrel = "bAMKEx_CONUS_Range_2001v1",
  fishcrow = "bFICRx_CONUS_Range_2001v1",
  tricoloredblackbird = "bTRBLx_CONUS_Range_2001v1",
  brewersblack = "bBRBLx_CONUS_Range_2001v1",
  blackcrownednightheron = "bBCNHx_CONUS_Range_2001v1",
  greathornedowl = "bGHOWx_CONUS_Range_2001v1",
  redtailedhawk = "bRTHAx_CONUS_Range_2001v1")


## C. read in files
bird_ranges <- lapply(names(species_list), function(species) {
  read_birdrange(species, species_list[[species]])
})

# add column names of species
names(bird_ranges) <- paste0("range_", names(species_list))

## D. decide if species is present/absent per county
# check intersection
bird_intersection <- function(counties, species_name, bird_range) {
  intersected <- st_intersects(counties$geometry, bird_range)
  as.integer(lengths(intersected) > 0)
}

# apply intersection for each bird species
bird_columns <- map2_dfc(names(bird_ranges), bird_ranges, ~ {
  col <- bird_intersection(counties_sf, .x, .y)
  setNames(data.frame(col), .x)
})

# add county metadata
bird_columns_county <- bind_cols(counties_sf, bird_columns)

## E. tally bird species per county
bird_tally_county <- bird_columns_county %>% 
  mutate(birds_tot = rowSums(across(range_bluejay:range_redtailedhawk)))


## F. plot it!
ggplot(bird_tally_county) +
  geom_sf(aes(fill = birds_tot), color = NA, size = 0.05, show.legend = TRUE) +
  geom_sf(data = states_sf, fill = NA, color = "black", size = 0.2) +
  coord_sf(xlim = c(-125, -66.5), ylim = c(24, 50), expand = FALSE)

# write csv
bird_tally_county %>% st_drop_geometry() %>% dplyr::select(GEOID,birds_tot) %>% 
  write.csv("data/processed/usgs_birds.csv")
```


#Merge
(everything but temperature-driven R0(T))

```{r}
## human incidence
wnv <- read.csv("data/processed/arbonet_wnvnd.csv")  %>% 
  mutate(GEOID = str_pad(GEOID, width = 5, pad = 0), # make sure FIPS are 5 characters
         GEOID = as.character(GEOID)) %>% dplyr::select(-X)

range(wnv$incidence, na.rm = TRUE) # 0.01 14.87 so dont need to add 1 to log transformation

over65 <- read.csv("data/processed/acs_over65.csv") %>% 
  mutate(GEOID = str_pad(GEOID, width = 5, pad = 0), # make sure FIPS are 5 characters
         GEOID = as.character(GEOID)) %>% dplyr::select(-X)


## landscape
edge <- read.csv("data/processed/nlcd_urbanag_edgesummary.csv") %>% 
  mutate(GEOID = str_pad(GEOID, width = 5, pad = 0), # make sure FIPS are 5 characters
         GEOID = as.character(GEOID)) %>% dplyr::select(-X)

## human exposure
occupation <- read.csv("data/processed/bls_agemployed.csv") %>% 
  mutate(GEOID = str_pad(GEOID, width = 5, pad = 0), # make sure FIPS are 5 characters
         GEOID = as.character(GEOID)) %>% dplyr::select(-X)

resident <- read.csv("data/processed/cdc_svi.csv") %>% 
  mutate(GEOID = str_pad(GEOID, width = 5, pad = 0), # make sure FIPS are 5 characters
         GEOID = as.character(GEOID)) %>% dplyr::select(-X)

## bird
bird <- read.csv("data/processed/usgs_birds.csv") %>% 
  mutate(GEOID = str_pad(GEOID, width = 5, pad = 0), # make sure FIPS are 5 characters
         GEOID = as.character(GEOID)) %>% dplyr::select(-X)

gam_covariates_noR0 <- counties_sf %>% 
  # formate spatial data
  st_drop_geometry() %>% 
  dplyr::select(STATEFP, GEOID) %>% 
  left_join(county_centroids %>% dplyr::select(GEOID, lat, lon) %>% st_drop_geometry(), by = "GEOID") %>% 
  # add covariate
  left_join(wnv , by = "GEOID") %>% 
  left_join(over65, by = "GEOID") %>% 
  left_join(edge, by = "GEOID") %>% 
  left_join(occupation, by = "GEOID") %>% 
  left_join(resident, by = "GEOID") %>% 
  left_join(bird, by = "GEOID") %>% 
  # add raw to indicate this was untransformed data
  rename_with(~ paste0("raw_", .), -c(STATEFP, GEOID, lat, lon)) %>% 
  # scale columns 
  mutate(across(starts_with("raw_"), # selects raw data columns
                ~ scale(.)[,1], #scales the data
                .names = "scale_{sub('^raw_', '', .col)}")) %>% # gives new column names
  rename_with(~ str_replace_all(., "edge_density", "edgedensity")) %>% # make edge density less of a headache
  dplyr::select(-scale_incidence) %>% # remove this variable bc it makes no sense when its out outcome
  mutate(log_incidence = log(raw_incidence)) %>% 
  dplyr::select(STATEFP, GEOID, lat, lon, log_incidence, raw_incidence:scale_birds_tot)


write.csv(gam_covariates_noR0,"data/processed/gam_covariates_noR0.csv")
  
```

